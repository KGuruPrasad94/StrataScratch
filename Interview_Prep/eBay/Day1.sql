-- üìò SQL Interview Practice Breakdown (eBay - Data Analyst Role)

-- üîπ Question 1 ‚Äì Medium: 30-Day Active Customers
-- ‚úÖ Question:
-- Find customers who placed at least one order in each of three consecutive months.
-- Assume the most recent month in the dataset is June 2023.
-- üóÉÔ∏è Table: orders
-- Columns: customer_id (INT), order_date (DATE)

-- ‚ùå User's Original Solution Attempt:
SELECT DISTINCT customer_id
FROM orders o1
JOIN orders o2
JOIN orders o3
  ON o1.order_date = DATE_ADD(o2.order_date, INTERVAL 1 MONTH)
  AND o2.order_date = DATE_ADD(o3.order_date, INTERVAL 1 MONTH)
WHERE o1.order_date > o2.order_date
  AND o2.order_date > o3.order_date;

-- üí° Issues in the Original Query:
-- 1. JOIN syntax is incorrect ‚Äî missing ON clause between o1 and o2.
-- 2. Date comparison assumes exact one-month differences, which is not reliable across all month lengths.
-- 3. The query does not check if the three dates are from the same customer.
-- 4. No grouping or filtering logic to ensure all 3 months are covered.

-- ‚úÖ Corrected and Optimized Query:
SELECT customer_id
FROM orders
WHERE order_date >= DATE_SUB('2023-07-01', INTERVAL 3 MONTH)
  AND order_date < '2023-07-01'
GROUP BY customer_id
HAVING COUNT(DISTINCT DATE_FORMAT(order_date, '%Y-%m')) = 3;

-- ‚úÖ Ideal/Easy-to-Understand Interview Version:
-- Count distinct year-month pairs and ensure the count is 3
SELECT customer_id
FROM orders
WHERE order_date BETWEEN '2023-04-01' AND '2023-06-30'
GROUP BY customer_id
HAVING COUNT(DISTINCT DATE_FORMAT(order_date, '%Y-%m')) = 3;

-- üßê Explanation:
-- - Filters for orders from April, May, and June 2023.
-- - Groups by customer_id.
-- - Checks if the customer ordered in all 3 different months.

-- üîπ Question 2 ‚Äì Medium: Month-over-Month Revenue Change
-- ‚úÖ Question:
-- Calculate the revenue generated by each customer month-over-month, and display the change in revenue from the previous month.
-- üóÉÔ∏è Table: orders
-- Columns: customer_id (INT), order_date (DATE), total_order_cost (FLOAT)

-- ‚ùå User's Original Solution Attempt:
WITH current_revenue AS (
  SELECT customer_id, SUM(total_order_cost) AS current_tot_rev
  FROM orders
  WHERE MONTH(order_date) = MONTH(CURRENT_DATE)
  GROUP BY customer_id
),

prev_revenue AS (
  SELECT customer_id, SUM(total_order_cost) AS prev_tot_rev
  FROM orders
  WHERE MONTH(order_date) = MONTH(CURRENT_DATE) - 1
  GROUP BY customer_id
)

SELECT c.customer_id, 
       (current_tot_rev - prev_tot_rev) / prev_tot_rev AS mom_rev_change
FROM current_revenue c 
JOIN prev_revenue p ON c.customer_id = p.customer_id;

-- üí° Issues in the Original Query:
-- 1. Both CTEs are using MONTH(CURRENT_DATE), but month alone is not enough ‚Äî it may mismatch years.
-- 2. Doesn‚Äôt account for customers who only ordered in the previous month (missing from final join).
-- 3. Calculation may error out on division by zero if prev_tot_rev = 0 (safeguard needed).
-- 4. Use of DATE_FORMAT is more reliable for filtering by year and month.

-- ‚úÖ Corrected and Optimized Query:
WITH current_revenue AS (
  SELECT customer_id, SUM(total_order_cost) AS current_tot_rev
  FROM orders
  WHERE DATE_FORMAT(order_date, '%Y-%m') = DATE_FORMAT(DATE_SUB(CURRENT_DATE, INTERVAL 1 MONTH), '%Y-%m')
  GROUP BY customer_id
),

prev_revenue AS (
  SELECT customer_id, SUM(total_order_cost) AS prev_tot_rev
  FROM orders
  WHERE DATE_FORMAT(order_date, '%Y-%m') = DATE_FORMAT(DATE_SUB(CURRENT_DATE, INTERVAL 2 MONTH), '%Y-%m')
  GROUP BY customer_id
)

SELECT c.customer_id, 
       ROUND((current_tot_rev - prev_tot_rev) / NULLIF(prev_tot_rev, 0), 2) AS mom_rev_change
FROM current_revenue c
JOIN prev_revenue p ON c.customer_id = p.customer_id;

-- ‚úÖ Ideal/Easy-to-Understand Interview Version:
-- Compare revenue by year-month strings using LEFT JOIN to retain customers from both months
WITH revenue_by_month AS (
  SELECT customer_id,
         DATE_FORMAT(order_date, '%Y-%m') AS year_month,
         SUM(total_order_cost) AS total_revenue
  FROM orders
  GROUP BY customer_id, year_month
),

ranked_revenue AS (
  SELECT *,
         -- Get previous month's revenue using LAG
         LAG(total_revenue) OVER (PARTITION BY customer_id ORDER BY year_month) AS prev_month_revenue
  FROM revenue_by_month
)

SELECT customer_id,
       year_month,
       ROUND((total_revenue - prev_month_revenue) / NULLIF(prev_month_revenue, 0), 2) AS mom_change
FROM ranked_revenue
WHERE prev_month_revenue IS NOT NULL;

-- üóôÔ∏è Explanation:
-- - DATE_FORMAT formats the order_date to 'YYYY-MM' to aggregate monthly.
-- - LAG gets each customer's previous month's revenue.
-- - We calculate change by comparing to previous value.

-- üóôÔ∏è STR_TO_DATE explanation:
-- STR_TO_DATE('2023-01', '%Y-%m') turns a string into a date (2023-01-01)
-- This enables us to do DATE_ADD operations like:
-- DATE_ADD(STR_TO_DATE('2023-01', '%Y-%m'), INTERVAL 3 MONTH) => 2023-04-01
-- Useful in cohort-based retention logic.

-- üîπ Question 3 ‚Äì Hard: User Retention Cohort
-- ‚úÖ Question:
-- Group users into cohorts based on the month of their first login, and calculate retention rate for each cohort over the next 3 months.
-- üóÉÔ∏è Table: user_logins
-- Columns: user_id (INT), login_date (DATE)

-- ‚ùå Original Attempt (had logical structure issues)

-- ‚úÖ Ideal/Easy-to-Understand Interview Version:
WITH first_logins AS (
  SELECT user_id, MIN(DATE_FORMAT(login_date, '%Y-%m')) AS cohort_month
  FROM user_logins
  GROUP BY user_id
),

cohort_activity AS (
  SELECT f.cohort_month,
         DATE_FORMAT(u.login_date, '%Y-%m') AS activity_month,
         COUNT(DISTINCT u.user_id) AS active_users
  FROM first_logins f
  JOIN user_logins u ON f.user_id = u.user_id
  WHERE DATE_FORMAT(u.login_date, '%Y-%m') BETWEEN f.cohort_month AND DATE_FORMAT(DATE_ADD(STR_TO_DATE(f.cohort_month, '%Y-%m'), INTERVAL 3 MONTH), '%Y-%m')
  GROUP BY f.cohort_month, activity_month
),

cohort_size AS (
  SELECT cohort_month, COUNT(*) AS cohort_users
  FROM first_logins
  GROUP BY cohort_month
)

SELECT c.cohort_month,
       a.activity_month,
       ROUND(a.active_users / cs.cohort_users, 2) AS retention_rate
FROM cohort_activity a
JOIN cohort_size cs ON a.cohort_month = cs.cohort_month
ORDER BY cohort_month, activity_month;

-- üßê Explanation:
-- - Groups users by their first login month.
-- - Calculates how many from the cohort were active in each of the next 3 months.
-- - STR_TO_DATE is used to convert 'YYYY-MM' to full date for date math.
-- - Calculates monthly retention as a percentage.
